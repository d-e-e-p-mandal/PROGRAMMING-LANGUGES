# Unit 3: Constructors and Destructors – Detailed Notes (Markdown Format)

### 1. Introduction and Purpose

Constructors and destructors are special member functions of a class in object-oriented programming.

Constructor
	•	A constructor is a special function automatically called when an object is created.
	•	Used to initialize data members of the class.
	•	Shares the same name as the class.
	•	Has no return type, not even void.

Destructor
	•	A destructor is a special function automatically called when an object goes out of scope or is deleted.
	•	Used for cleanup activities (like releasing memory).
	•	Shares the same name as the class but is prefixed with a ~ symbol.
	•	Only in C++ (Java uses Garbage Collector instead of destructors).

⸻

### 2. Types of Constructors

A. Default Constructor

A constructor that takes no arguments.

Example (C++)

class Demo {
public:
    Demo() {  // default constructor
        cout << "Default Constructor Invoked";
    }
};

Example (Java)

class Demo {
    Demo() { // default constructor
        System.out.println("Default Constructor Invoked");
    }
}


⸻

B. Parameterized Constructor

A constructor that takes one or more parameters.

Example (C++)

class Demo {
public:
    int x;
    Demo(int n) { // parameterized
        x = n;
    }
};

Example (Java)

class Demo {
    int x;
    Demo(int n) {  // parameterized
        x = n;
    }
}


⸻

C. Copy Constructor (C++)

A constructor that creates a new object as a copy of an existing object.

Default Copy Constructor
Provided automatically by the compiler.

User-Defined Copy Constructor

class Demo {
public:
    int x;
    Demo(int n) { x = n; }

    Demo(const Demo &obj) {  // copy constructor
        x = obj.x;
    }
};

Java does NOT have a copy constructor. Objects are copied via cloning or assignment of references.

----

### 3. Constructor Overloading

Multiple constructors with the same name but different number or type of parameters.

Example (C++)

class Demo {
public:
    Demo() { }
    Demo(int a) { }
    Demo(int a, int b) { }
};

Example (Java)

class Demo {
    Demo() { }
    Demo(int a) { }
    Demo(int a, int b) { }
}

Overloading helps initialize objects in different ways.

----

### 4. Destructor (C++)
	•	Destructor name = ~ClassName()
	•	No return type
	•	No parameters (cannot be overloaded)
	•	Automatically called when:
	•	Object goes out of scope
	•	delete is used

Example

class Demo {
public:
    ~Demo() {
        cout << "Destructor Called";
    }
};

In Java: No destructor. Garbage Collector handles cleanup.

⸻

### 5. Order of Constructor and Destructor Invocation

For Constructors (C++)
	•	Base class constructor is called first.
	•	Derived class constructor is called next.

For Destructors (C++)
	•	Order is reverse of constructors.
	•	Derived class destructor is called first.
	•	Base class destructor is called last.

Example
```CPP
class A {
public:
    A() { cout << "A Constructor"; }
    ~A() { cout << "A Destructor"; }
};

class B : public A {
public:
    B() { cout << "B Constructor"; }
    ~B() { cout << "B Destructor"; }
};

int main() {
    B obj;
}
```
Output sequence:

A Constructor
B Constructor
B Destructor
A Destructor


⸻

### 6. Dynamic Initialization of Objects

Objects can be initialized at runtime using:
	•	Parameters
	•	Variables
	•	Expressions
	•	Values from user input

Example (C++)
```CPP
class Demo {
public:
    int x;
    Demo(int n) {
        x = n;
    }
};

int main() {
    int value;
    cin >> value;
    Demo d(value); // runtime initialization
}
```
Example (Java)
```JAVA
class Demo {
    int x;
    Demo(int n) {
        x = n;
    }
}

public class Main {
    public static void main(String[] args) {
        int value = 10;
        Demo d = new Demo(value);
    }
}
```
Dynamic initialization allows flexibility and supports real-time decision making.

----